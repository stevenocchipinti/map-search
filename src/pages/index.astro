---
import Layout from '../layouts/Layout.astro';
import { MapPin, X, Search, Locate, GraduationCap, TrainFront, ShoppingCart, ChevronDown, Loader2 } from 'lucide-astro';
---

<Layout>
	<div class="flex h-full">
		<!-- Sidebar -->
		<aside id="sidebar" class="w-full md:w-80 lg:w-96 bg-white border-r border-gray-200 flex flex-col overflow-hidden md:relative absolute inset-0 z-20 md:z-auto transition-transform md:translate-x-0" data-collapsed="false">
			<!-- Header -->
			<div class="p-5 border-b border-gray-100 flex-shrink-0 bg-white z-10 shadow-sm">
				<div class="flex items-center justify-between mb-6">
					<div class="flex items-center gap-2">
						<div class="bg-blue-600 rounded-lg p-1.5 text-white">
							<MapPin class="w-5 h-5" />
						</div>
						<h1 class="text-xl font-bold text-gray-900 tracking-tight">School Finder</h1>
					</div>
					<button id="toggle-sidebar" class="md:hidden p-2 text-gray-500 hover:bg-gray-100 rounded-full transition-colors" aria-label="Toggle sidebar">
						<X class="w-5 h-5" />
					</button>
				</div>
				
				<!-- Search Form -->
				<div class="space-y-4">
					<!-- Address Input -->
					<div class="relative group">
						<div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none text-gray-400 group-focus-within:text-blue-500 transition-colors">
							<Search class="w-5 h-5" />
						</div>
						<input
							type="text"
							id="address"
							name="address"
							placeholder="Search suburb or address..."
							class="w-full pl-10 pr-10 py-3 text-sm border border-gray-200 rounded-xl bg-gray-50 focus:bg-white focus:ring-2 focus:ring-blue-500/20 focus:border-blue-500 outline-none transition-all shadow-sm"
						/>
						<button
							type="button"
							id="location-btn"
							class="absolute inset-y-0 right-0 pr-3 flex items-center cursor-pointer text-gray-400 hover:text-blue-600 transition-colors"
							title="Use my current location"
						>
							<Locate class="w-5 h-5" />
						</button>
					</div>
					
					<!-- Buttons -->
						<button
						type="button"
						id="search-btn"
						class="w-full py-3 bg-gray-900 text-white text-sm font-semibold rounded-xl hover:bg-gray-800 focus:ring-4 focus:ring-gray-200 disabled:opacity-50 disabled:cursor-not-allowed transition-all shadow-sm flex items-center justify-center gap-2"
					>
						<span>Find nearby</span>
						<Loader2 id="loading-spinner" class="hidden animate-spin h-4 w-4" />
					</button>
					
					<!-- Sector Filters -->
					<div class="space-y-2 pt-2">
						<span class="text-xs font-semibold text-gray-400 uppercase tracking-wider pl-1">School Types</span>
						<div class="flex flex-wrap gap-2">
							<label class="group relative flex items-center justify-center">
								<input type="checkbox" name="sector" value="Government" checked class="peer sr-only" />
								<div class="px-3 py-1.5 rounded-full border border-gray-200 text-xs font-medium text-gray-600 bg-white peer-checked:bg-blue-50 peer-checked:text-blue-700 peer-checked:border-blue-200 cursor-pointer transition-all hover:bg-gray-50 flex items-center gap-1.5 shadow-sm">
									<span class="w-1.5 h-1.5 rounded-full bg-blue-500"></span>
									Government
								</div>
							</label>
							<label class="group relative flex items-center justify-center">
								<input type="checkbox" name="sector" value="Catholic" class="peer sr-only" />
								<div class="px-3 py-1.5 rounded-full border border-gray-200 text-xs font-medium text-gray-600 bg-white peer-checked:bg-orange-50 peer-checked:text-orange-700 peer-checked:border-orange-200 cursor-pointer transition-all hover:bg-gray-50 flex items-center gap-1.5 shadow-sm">
									<span class="w-1.5 h-1.5 rounded-full bg-orange-500"></span>
									Catholic
								</div>
							</label>
							<label class="group relative flex items-center justify-center">
								<input type="checkbox" name="sector" value="Independent" class="peer sr-only" />
								<div class="px-3 py-1.5 rounded-full border border-gray-200 text-xs font-medium text-gray-600 bg-white peer-checked:bg-purple-50 peer-checked:text-purple-700 peer-checked:border-purple-200 cursor-pointer transition-all hover:bg-gray-50 flex items-center gap-1.5 shadow-sm">
									<span class="w-1.5 h-1.5 rounded-full bg-purple-500"></span>
									Independent
								</div>
							</label>
						</div>
					</div>
				</div>
			</div>
			
			<!-- Results Area -->
			<div id="results-container" class="flex-1 overflow-y-auto p-4 space-y-4">
				<!-- Initial State -->
				<div id="initial-state" class="text-center text-gray-500 py-8">
					<Search class="h-12 w-12 mx-auto mb-3 text-gray-300" />
					<p class="text-sm">Enter an address to find nearby schools, train stations, and supermarkets within walking distance.</p>
				</div>
				
				<!-- Card Containers -->
				<div id="cards-container" class="space-y-4">
				<!-- School Card -->
				<div id="school-card-container" class="bg-white border border-gray-200 rounded-lg overflow-hidden shadow-sm hover:shadow-md transition-shadow">
					<!-- Primary Card -->
					<div id="school-primary-card" class="p-4">
						<div class="flex items-center gap-3 text-gray-400">
							<div class="w-10 h-10 rounded-full bg-gray-100 flex items-center justify-center">
								<GraduationCap class="w-5 h-5" />
							</div>
							<span class="font-medium">Schools</span>
						</div>
					</div>
					
					<!-- Alternatives Toggle -->
					<div id="school-alternatives-toggle" class="hidden border-t border-gray-200 px-4 py-3 hover:bg-gray-50 cursor-pointer transition">
						<button class="text-blue-600 hover:text-blue-700 text-sm font-medium w-full flex items-center justify-between">
							<span>View <span class="school-alt-count">0</span> more options</span>
							<ChevronDown class="w-4 h-4 transform transition-transform" />
						</button>
					</div>
					
					<!-- Alternatives List -->
					<div id="school-alternatives" class="hidden border-t border-gray-200 max-h-60 overflow-y-auto bg-gray-50">
						<!-- Populated by JavaScript -->
					</div>
				</div>
				
				<!-- Station Card -->
				<div id="station-card-container" class="bg-white border border-gray-200 rounded-lg overflow-hidden shadow-sm hover:shadow-md transition-shadow">
					<div id="station-primary-card" class="p-4">
						<div class="flex items-center gap-3 text-gray-400">
							<div class="w-10 h-10 rounded-full bg-gray-100 flex items-center justify-center">
								<TrainFront class="w-5 h-5" />
							</div>
							<span class="font-medium">Train Stations</span>
						</div>
					</div>
					
					<div id="station-alternatives-toggle" class="hidden border-t border-gray-200 px-4 py-3 hover:bg-gray-50 cursor-pointer transition">
						<button class="text-blue-600 hover:text-blue-700 text-sm font-medium w-full flex items-center justify-between">
							<span>View <span class="station-alt-count">0</span> more options</span>
							<ChevronDown class="w-4 h-4 transform transition-transform" />
						</button>
					</div>
					
					<div id="station-alternatives" class="hidden border-t border-gray-200 max-h-60 overflow-y-auto bg-gray-50">
					</div>
				</div>
					
				<!-- Supermarket Card -->
				<div id="grocery-card-container" class="bg-white border border-gray-200 rounded-lg overflow-hidden shadow-sm hover:shadow-md transition-shadow">
					<div id="grocery-primary-card" class="p-4">
						<div class="flex items-center gap-3 text-gray-400">
							<div class="w-10 h-10 rounded-full bg-gray-100 flex items-center justify-center">
								<ShoppingCart class="w-5 h-5" />
							</div>
							<span class="font-medium">Supermarkets</span>
						</div>
					</div>
					
					<div id="grocery-alternatives-toggle" class="hidden border-t border-gray-200 px-4 py-3 hover:bg-gray-50 cursor-pointer transition">
						<button class="text-blue-600 hover:text-blue-700 text-sm font-medium w-full flex items-center justify-between">
							<span>View <span class="grocery-alt-count">0</span> more options</span>
							<ChevronDown class="w-4 h-4 transform transition-transform" />
						</button>
					</div>
					
					<div id="grocery-alternatives" class="hidden border-t border-gray-200 max-h-60 overflow-y-auto bg-gray-50">
					</div>
				</div>
				</div>
				
				<!-- Error Message -->
				<div id="error-message" class="hidden m-4 p-3 bg-red-50 border border-red-200 text-red-700 rounded-lg text-sm"></div>
			</div>
		</aside>
		
		<!-- Mobile Toggle Button -->
		<button id="open-sidebar" class="md:hidden fixed bottom-4 left-4 z-30 p-3 bg-blue-600 text-white rounded-full shadow-lg hover:bg-blue-700 transition-colors">
			<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
				<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
			</svg>
		</button>
		
		<!-- Map Container -->
		<div class="flex-1 relative">
			<div id="map" class="absolute inset-0 z-0"></div>
		</div>
	</div>
</Layout>

<style>
	#sidebar[data-collapsed="true"] {
		transform: translateX(-100%);
	}
	
	@media (min-width: 768px) {
		#sidebar[data-collapsed="true"] {
			transform: translateX(0);
		}
	}

	/* Card styles */
	.time-badge {
		display: inline-flex;
		align-items: center;
		gap: 0.375rem;
		padding: 0.25rem 0.625rem;
		border-radius: 9999px;
		font-size: 0.75rem;
		font-weight: 600;
		letter-spacing: 0.025em;
	}

	.time-badge.estimate {
		background-color: #f3f4f6;
		color: #4b5563;
	}

	.time-badge.actual {
		background-color: #eff6ff;
		color: #2563eb;
	}

	.distance-badge {
		display: inline-flex;
		align-items: center;
		gap: 0.25rem;
		font-size: 0.75rem;
		color: #6b7280;
		font-weight: 500;
	}

	.alternative-item {
		padding: 0.875rem 1rem;
		border-bottom: 1px solid #f3f4f6;
		cursor: pointer;
		transition: all 0.2s ease;
		background-color: white;
	}

	.alternative-item:hover {
		background-color: #f9fafb;
		padding-left: 1.25rem;
	}

	.alternative-item:last-child {
		border-bottom: none;
	}
	
	.custom-scrollbar::-webkit-scrollbar {
		width: 6px;
	}
	
	.custom-scrollbar::-webkit-scrollbar-track {
		background: transparent;
	}
	
	.custom-scrollbar::-webkit-scrollbar-thumb {
		background-color: #e5e7eb;
		border-radius: 20px;
	}

	.loading-state {
		display: inline-flex;
		align-items: center;
		gap: 0.5rem;
		color: #9ca3af;
		font-size: 0.875rem;
	}

	.loading-state::after {
		content: '';
		display: inline-block;
		width: 0.5rem;
		height: 0.5rem;
		border-radius: 50%;
		background-color: #d1d5db;
		animation: pulse 1.5s ease-in-out infinite;
	}

	@keyframes pulse {
		0%, 100% {
			opacity: 1;
		}
		50% {
			opacity: 0.5;
		}
	}
</style>

<script>
	// Types
	interface School {
		name: string;
		suburb: string;
		state: string;
		postcode: string;
		sector: 'Government' | 'Catholic' | 'Independent';
		type: string;
		latitude: number;
		longitude: number;
		distance: number;
		walkingTime: number | null;
		walkingPath: GeoJSON.LineString | null;
	}

	interface POI {
		id: string;
		name: string;
		lat: number;
		lng: number;
		type: 'station' | 'grocery';
		distance: number;
		walkingTime: number | null;
		walkingPath: GeoJSON.LineString | null;
	}

	interface SearchResponse {
		userLocation: {
			lat: number;
			lng: number;
			address: string;
		};
		results: {
			schools: School[];
			stations: POI[];
			groceries: POI[];
		};
		errors: {
			schools?: string;
			stations?: string;
			groceries?: string;
		};
	}

	interface CachedRoute {
		walkingTime: number;
		walkingPath: GeoJSON.LineString;
		distance: number;
	}

	// DOM Elements
	const sidebar = document.getElementById('sidebar') as HTMLElement;
	const toggleSidebarBtn = document.getElementById('toggle-sidebar') as HTMLButtonElement;
	const openSidebarBtn = document.getElementById('open-sidebar') as HTMLButtonElement;
	const addressInput = document.getElementById('address') as HTMLInputElement;
	const searchBtn = document.getElementById('search-btn') as HTMLButtonElement;
	const locationBtn = document.getElementById('location-btn') as HTMLButtonElement;
	const loadingSpinner = document.getElementById('loading-spinner') as HTMLElement;
	const errorMessage = document.getElementById('error-message') as HTMLElement;
	const sectorCheckboxes = document.querySelectorAll<HTMLInputElement>('input[name="sector"]');
	const initialState = document.getElementById('initial-state') as HTMLElement;
	const cardsContainer = document.getElementById('cards-container') as HTMLElement;
	
	// Marker colors
	const colors = {
		user: '#ef4444',
		government: '#3b82f6',
		catholic: '#f97316',
		independent: '#a855f7',
		station: '#0891b2', // Cyan/teal color to distinguish from red user marker
		grocery: '#eab308'
	};

	// Initialize map
	const map = L.map('map').setView([-25.2744, 133.7751], 4);
	L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
		attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
	}).addTo(map);

	// State
	let markers: Map<string, L.Marker> = new Map();
	let polylines: Map<string, L.Layer> = new Map();
	let currentResults: SearchResponse | null = null;
	let userLat: number = 0;
	let userLng: number = 0;
	let routeCache: Map<string, CachedRoute> = new Map();
	let selectedIndices = { school: 0, station: 0, grocery: 0 };

	// Icons - Lucide SVG paths
	const icons = {
		school: '<path d="M21.42 10.922a1 1 0 0 0-.019-1.838L12.83 5.18a2 2 0 0 0-1.66 0L2.6 9.08a1 1 0 0 0 0 1.832l8.57 3.908a2 2 0 0 0 1.66 0z"/><path d="M22 10v6"/><path d="M6 12.5V16a6 3 0 0 0 12 0v-3.5"/>',
		station: '<path d="M8 3.1V7a4 4 0 0 0 8 0V3.1"/><path d="m9 15-1-1"/><path d="m15 15 1-1"/><path d="M9 19c-2.8 0-5-2.2-5-5v-4a8 8 0 0 1 16 0v4c0 2.8-2.2 5-5 5Z"/><path d="m8 19-2 3"/><path d="m16 19 2 3"/>',
		grocery: '<circle cx="8" cy="21" r="1"/><circle cx="19" cy="21" r="1"/><path d="M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12"/>',
		user: '<path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/>'
	};

	// Helper to get SVG icon for category (used in JavaScript-generated HTML)
	function getIconSvg(type: 'school' | 'station' | 'grocery' | 'user'): string {
		return `<svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24">${icons[type]}</svg>`;
	}

	// Create marker icon
	function createMarkerIcon(type: 'school' | 'station' | 'grocery' | 'user', color: string, isSelected: boolean): L.DivIcon {
		if (type === 'user') {
			return L.divIcon({
				className: 'user-marker',
				html: `<div style="width: 16px; height: 16px; background-color: ${color}; border: 3px solid white; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
				iconSize: [20, 20],
				iconAnchor: [10, 10]
			});
		}

		if (isSelected) {
			const svg = `
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 42" width="32" height="42">
				<path d="M16 0C7.16 0 0 7.16 0 16c0 8.84 16 26 16 26s16-17.16 16-26c0-8.84-7.16-16-16-16z" fill="${color}" stroke="white" stroke-width="2"/>
				<g transform="translate(6, 6)">
					<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						${icons[type]}
					</svg>
				</g>
			</svg>`;
			
			return L.divIcon({
				className: 'custom-pin-marker',
				html: svg,
				iconSize: [32, 42],
				iconAnchor: [16, 42],
				popupAnchor: [0, -42]
			});
		} else {
			return L.divIcon({
				className: 'custom-dot-marker',
				html: `<div style="
					width: 14px;
					height: 14px;
					background-color: white;
					border: 3px solid ${color};
					border-radius: 50%;
					box-shadow: 0 1px 2px rgba(0,0,0,0.2);
				"></div>`,
				iconSize: [14, 14],
				iconAnchor: [7, 7],
				popupAnchor: [0, -7]
			});
		}
	}

	// Get selected sectors
	function getSelectedSectors(): string[] {
		return Array.from(sectorCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
	}

	// Set selected sectors
	function setSelectedSectors(sectors: string[]): void {
		sectorCheckboxes.forEach(cb => { cb.checked = sectors.includes(cb.value); });
	}

	// Toggle sidebar
	function toggleSidebar(show?: boolean): void {
		const isCollapsed = sidebar.dataset.collapsed === 'true';
		// If show is true, we want isCollapsed to be false.
		// If show is undefined, we toggle isCollapsed.
		const shouldCollapse = show !== undefined ? !show : !isCollapsed;
		
		sidebar.dataset.collapsed = String(shouldCollapse);
		
		// If sidebar is collapsed (hidden), we show the open button
		openSidebarBtn.classList.toggle('hidden', !shouldCollapse);
	}

	// Loading state
	function setLoading(loading: boolean): void {
		searchBtn.disabled = loading;
		locationBtn.disabled = loading;
		loadingSpinner.classList.toggle('hidden', !loading);
	}

	// Clear markers and polylines
	function clearMarkers(): void {
		markers.forEach(marker => marker.remove());
		markers.clear();
		polylines.forEach(line => line.remove());
		polylines.clear();
	}

	// Cache key generator
	function getCacheKey(from: { lat: number; lng: number }, to: { lat: number; lng: number }, category: string, itemId: string): string {
		const fromKey = `${Math.round(from.lat * 1000)}-${Math.round(from.lng * 1000)}`;
		const toKey = `${Math.round(to.lat * 1000)}-${Math.round(to.lng * 1000)}`;
		return `${fromKey}-${toKey}-${category}-${itemId}`;
	}

	// Draw walking path on map
	function drawWalkingPath(category: 'school' | 'station' | 'grocery', walkingPath: GeoJSON.LineString): void {
		const polylineKey = `${category}-polyline`;
		// Remove existing polyline if present
		if (polylines.has(polylineKey)) {
			polylines.get(polylineKey)!.remove();
		}
		// Draw new polyline
		const color = category === 'school' ? '#3b82f6' : category === 'station' ? '#0891b2' : '#eab308';
		const line = L.geoJSON(walkingPath, {
			style: {
				color,
				weight: 4,
				opacity: 0.7
			}
		}).addTo(map);
		polylines.set(polylineKey, line);
	}

	// Format time display
	function formatTime(walkingTime: number | null, distance: number, isLoading: boolean = false): string {
		if (isLoading) {
			return '<span class="loading-state">Calculating</span>';
		}
		if (walkingTime !== null) {
			return `<div class="time-badge actual">üö∂ ${walkingTime} min walk</div>`;
		}
		const estimate = Math.round(distance * 1.4 * 60 / 5);
		return `<div class="time-badge estimate">üö∂ ~${estimate} min <span class="label">(estimate)</span></div>`;
	}

	// Format distance
	function formatDistance(distance: number): string {
		return `<div class="distance-badge">üìç ${distance.toFixed(2)} km</div>`;
	}

	// Update primary card
	function updatePrimaryCard(category: 'school' | 'station' | 'grocery', item: School | POI, isLoading: boolean = false): void {
		const cardId = `${category}-primary-card`;
		const card = document.getElementById(cardId) as HTMLElement;
		if (!card) return;

		const title = item.name;
		const details = category === 'school' 
			? `${(item as School).suburb}, ${(item as School).state} ¬∑ ${(item as School).type}`
			: category === 'station' ? 'Train Station' : 'Supermarket';

		const iconColor = category === 'school' 
			? colors[(item as School).sector.toLowerCase() as keyof typeof colors] || colors.government
			: category === 'station' ? colors.station : colors.grocery;

		card.innerHTML = `
			<div class="flex items-start gap-3">
				<div class="w-10 h-10 rounded-full bg-gray-100 flex items-center justify-center flex-shrink-0" style="color: ${iconColor}">
					${getIconSvg(category)}
				</div>
				<div class="flex-1 min-w-0">
					<h3 class="font-medium text-gray-900 truncate">${title}</h3>
					<p class="text-sm text-gray-500 truncate mb-2">${details}</p>
					<div class="flex items-center gap-2">
						${formatTime(item.walkingTime, item.distance, isLoading)}
						${formatDistance(item.distance)}
					</div>
				</div>
			</div>
		`;
	}

	// Create alternative item
	function createAlternativeItem(category: 'school' | 'station' | 'grocery', item: School | POI, index: number): HTMLElement {
		const div = document.createElement('div');
		div.className = 'alternative-item';
		
		const title = 'name' in item ? item.name : item.name;
		
		// Build details line based on category
		let details: string;
		if (category === 'school') {
			details = `${(item as School).suburb}, ${(item as School).state}`;
		} else if (category === 'station') {
			details = 'Train Station';
		} else {
			// For groceries, show street and suburb if available
			const grocery = item as POI;
			const detailParts: string[] = [];
			if ((grocery as any).street) detailParts.push((grocery as any).street);
			if ((grocery as any).suburb) detailParts.push((grocery as any).suburb);
			if ((grocery as any).postcode && detailParts.length === 0) detailParts.push((grocery as any).postcode);
			details = detailParts.length > 0 ? detailParts.join(', ') : 'Supermarket';
		}

		div.innerHTML = `
			<div class="flex items-start justify-between gap-2">
				<div class="flex-1 min-w-0">
					<p class="font-medium text-gray-900 truncate">${title}</p>
					<p class="text-xs text-gray-600 truncate">${details}</p>
				</div>
				<div class="text-right flex-shrink-0">
					<p class="text-sm text-gray-600">${item.walkingTime ? `${item.walkingTime} min` : `~${Math.round(item.distance * 1.4 * 60 / 5)} min`}</p>
					<p class="text-xs text-gray-500">${item.distance.toFixed(2)} km</p>
				</div>
			</div>
		`;

		div.addEventListener('click', () => selectAlternative(category, index));
		return div;
	}

	// Select alternative
	async function selectAlternative(category: 'school' | 'station' | 'grocery', index: number): Promise<void> {
		if (!currentResults) return;

		const items = category === 'school' 
			? currentResults.results.schools 
			: category === 'station' ? currentResults.results.stations : currentResults.results.groceries;

		if (index >= items.length) return;

		// Update selection state
		selectedIndices[category] = index;

		const item = items[index];
		const cacheKey = getCacheKey({ lat: userLat, lng: userLng }, { lat: item.latitude || item.lat, lng: item.longitude || item.lng }, category, (item as any).name || item.id);

		// Update markers for this category
		items.forEach((itm, idx) => {
			const itemId = (itm as any).name || itm.id;
			const markerKey = `${category}-${itemId}`;
			const marker = markers.get(markerKey);
			
			if (marker) {
				const isSelected = idx === index;
				const color = category === 'school' 
					? colors[(itm as School).sector?.toLowerCase() as keyof typeof colors] || colors.government
					: category === 'station' ? colors.station : colors.grocery;
				
				marker.setIcon(createMarkerIcon(category, color, isSelected));
				marker.setZIndexOffset(isSelected ? 1000 : 0); // Bring selected to front
			}
		});

		// Show loading state
		updatePrimaryCard(category, item, true);

		// Check cache first
		if (routeCache.has(cacheKey)) {
			const cached = routeCache.get(cacheKey)!;
			item.walkingTime = cached.walkingTime;
			item.walkingPath = cached.walkingPath;
		} else {
			// Fetch walking data
			try {
				const response = await fetch('/api/walking-routes', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						from: { lat: userLat, lng: userLng },
						to: { lat: item.latitude || item.lat, lng: item.longitude || item.lng },
						category,
						itemId: (item as any).name || item.id
					})
				});

				const data = await response.json();
				if (data.walkingTime !== null) {
					item.walkingTime = data.walkingTime;
					item.walkingPath = data.walkingPath;
					routeCache.set(cacheKey, { walkingTime: data.walkingTime, walkingPath: data.walkingPath, distance: data.distance });
				}
			} catch (error) {
				console.error(`Error fetching walking route for ${category}:`, error);
			}
		}

		// Update UI
		updatePrimaryCard(category, item, false);
		
		// Update map polyline
		if (item.walkingPath) {
			drawWalkingPath(category, item.walkingPath);
		}

		// Close alternatives (but keep toggle visible)
		const altList = document.getElementById(`${category}-alternatives`) as HTMLElement;
		const altToggle = document.getElementById(`${category}-alternatives-toggle`) as HTMLElement;
		
		if (altList) {
			altList.classList.add('hidden');
		}
		
		// Reset arrow rotation
		if (altToggle) {
			const svg = altToggle.querySelector('svg');
			if (svg) {
				svg.style.transform = 'rotate(0)';
			}
		}
	}

	// Fit map to show all relevant results
	function fitMapToResults(data: SearchResponse): void {
		const bounds = L.latLngBounds([]);
		
		// Add user location
		bounds.extend([data.userLocation.lat, data.userLocation.lng]);
		
		// Add first result from each category (the top/nearest ones)
		if (data.results.schools.length > 0) {
			const school = data.results.schools[0];
			bounds.extend([school.latitude, school.longitude]);
		}
		
		if (data.results.stations.length > 0) {
			const station = data.results.stations[0];
			bounds.extend([station.lat, station.lng]);
		}
		
		if (data.results.groceries.length > 0) {
			const grocery = data.results.groceries[0];
			bounds.extend([grocery.lat, grocery.lng]);
		}
		
		// Fit the map to the bounds with padding
		if (bounds.isValid()) {
			map.fitBounds(bounds, {
				padding: [50, 50], // 50px padding on all sides
				maxZoom: 15 // Don't zoom in too close
			});
		}
	}

	// Render results
	async function renderResults(data: SearchResponse): Promise<void> {
		currentResults = data;
		userLat = data.userLocation.lat;
		userLng = data.userLocation.lng;
		clearMarkers();

		// Show cards container
		initialState.classList.add('hidden');
		cardsContainer.classList.remove('hidden');

		// Add user marker
		const userMarker = L.marker([data.userLocation.lat, data.userLocation.lng], { icon: createMarkerIcon('user', colors.user, true) });
		userMarker.bindPopup(`<strong>Your Location</strong><br>${data.userLocation.address}`);
		userMarker.addTo(map);
		markers.set('user', userMarker);

		// Process each category
		const categories = [
			{ type: 'school' as const, items: data.results.schools, color: colors.government },
			{ type: 'station' as const, items: data.results.stations, color: colors.station },
			{ type: 'grocery' as const, items: data.results.groceries, color: colors.grocery }
		];

		// Reset selection indices
		selectedIndices = { school: 0, station: 0, grocery: 0 };

		for (const category of categories) {
			if (category.items.length === 0) {
				// Show empty state
				renderEmptyCategory(category.type);
				continue;
			}

			// Add markers for all items
			category.items.forEach((item, index) => {
				const markerColor = category.type === 'school' 
					? colors[(item as School).sector?.toLowerCase() as keyof typeof colors] || colors.government
					: category.color;
				
				const isSelected = index === 0;
				const marker = L.marker([item.latitude || item.lat, item.longitude || item.lng], { 
					icon: createMarkerIcon(category.type, markerColor, isSelected),
					zIndexOffset: isSelected ? 1000 : 0
				});
				
				// Add click handler
				marker.on('click', () => {
					selectAlternative(category.type, index);
				});

				marker.addTo(map);
				const itemId = (item as any).name || item.id;
				markers.set(`${category.type}-${itemId}`, marker);
			});

			// Update primary card
			updatePrimaryCard(category.type, category.items[0]);

			// Draw walking path if already available
			if (category.items[0].walkingPath) {
				drawWalkingPath(category.type, category.items[0].walkingPath);
			}

			// Handle alternatives
			const altContainer = document.getElementById(`${category.type}-alternatives`) as HTMLElement;
			const altToggle = document.getElementById(`${category.type}-alternatives-toggle`) as HTMLElement;
			const altList = document.getElementById(`${category.type}-alternatives`) as HTMLElement;

			if (category.items.length > 1) {
				// Populate alternatives
				altContainer.innerHTML = '';
				category.items.slice(1).forEach((item, idx) => {
					altContainer.appendChild(createAlternativeItem(category.type, item, idx + 1));
				});

				// Update the count in the toggle button
				const altCountSpans = document.querySelectorAll(`.${category.type}-alt-count`);
				altCountSpans.forEach(span => {
					span.textContent = String(category.items.length - 1);
				});

				// Show toggle
				altToggle.classList.remove('hidden');
				altToggle.onclick = () => {
					const isHidden = altList.classList.contains('hidden');
					altList.classList.toggle('hidden');
					// Rotate arrow
					const svg = altToggle.querySelector('svg');
					if (svg) {
						svg.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0)';
					}
				};
			} else {
				altToggle.classList.add('hidden');
				altList.classList.add('hidden');
			}
		}

		// Fit map to show user location and top result from each category
		fitMapToResults(data);

		// Start loading walking times for nearest 3
		loadNearestWalkingTimes();
	}

	// Render empty state
	function renderEmptyCategory(category: 'school' | 'station' | 'grocery'): void {
		const title = category === 'school' ? 'Schools' : category === 'station' ? 'Train Stations' : 'Supermarkets';
		const messages = {
			school: "No schools found within walking distance. Try a different location or adjust your search.",
			station: "No train stations nearby. You may be in a remote area.",
			grocery: "No supermarkets found within walking distance. Try expanding your search area."
		};

		const card = document.getElementById(`${category}-card-container`) as HTMLElement;
		const primary = document.getElementById(`${category}-primary-card`) as HTMLElement;
		
		primary.innerHTML = `
			<div class="text-center py-6">
				<p class="text-sm font-medium text-gray-900 mb-1">${title}</p>
				<p class="text-xs text-gray-600">${messages[category]}</p>
			</div>
		`;
	}

	// Load walking times for nearest 3
	async function loadNearestWalkingTimes(): Promise<void> {
		if (!currentResults) return;

		console.log('Starting loadNearestWalkingTimes');

		const toFetch = [
			{ category: 'school' as const, item: currentResults.results.schools[0] },
			{ category: 'station' as const, item: currentResults.results.stations[0] },
			{ category: 'grocery' as const, item: currentResults.results.groceries[0] }
		].filter(item => item.item);

		console.log(`Found ${toFetch.length} items to fetch walking times for`);

		for (const { category, item } of toFetch) {
			console.log(`Fetching walking time for ${category}: ${item.name || item.id}`);
			
			const cacheKey = getCacheKey(
				{ lat: userLat, lng: userLng },
				{ lat: item.latitude || item.lat, lng: item.longitude || item.lng },
				category,
				(item as any).name || item.id
			);

			if (routeCache.has(cacheKey)) {
				console.log(`Cache hit for ${category}`);
				const cached = routeCache.get(cacheKey)!;
				item.walkingTime = cached.walkingTime;
				item.walkingPath = cached.walkingPath;
				updatePrimaryCard(category, item);
				// Draw walking path if available
				if (item.walkingPath) {
					drawWalkingPath(category, item.walkingPath);
				}
				continue;
			}

			try {
				console.log(`Making API request for ${category}`);
				const response = await fetch('/api/walking-routes', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						from: { lat: userLat, lng: userLng },
						to: { lat: item.latitude || item.lat, lng: item.longitude || item.lng },
						category,
						itemId: (item as any).name || item.id
					})
				});

				const data = await response.json();
				console.log(`Received response for ${category}:`, data);
				
				if (data.walkingTime !== null) {
					item.walkingTime = data.walkingTime;
					item.walkingPath = data.walkingPath;
					routeCache.set(cacheKey, { walkingTime: data.walkingTime, walkingPath: data.walkingPath, distance: data.distance });
					console.log(`Updated ${category} with walking time: ${data.walkingTime} min`);
				}

				updatePrimaryCard(category, item);

				// Draw polyline if available
				if (item.walkingPath) {
					drawWalkingPath(category, item.walkingPath);
				}
			} catch (error) {
				console.error(`Error loading walking time for ${category}:`, error);
			}

			// Wait 1 second before next request to avoid rate limiting
			console.log(`Waiting 1 second before next request...`);
			await new Promise(resolve => setTimeout(resolve, 1000));
		}
		
		console.log('Finished loadNearestWalkingTimes');
	}

	// Handle search
	async function handleSearch(): Promise<void> {
		const address = addressInput.value.trim();
		const sectors = getSelectedSectors();

		if (!address && !navigator.geolocation) {
			errorMessage.textContent = 'Please enter an address or enable location access.';
			errorMessage.classList.remove('hidden');
			return;
		}

		if (!sectors.length) {
			errorMessage.textContent = 'Please select at least one school sector.';
			errorMessage.classList.remove('hidden');
			return;
		}

		errorMessage.classList.add('hidden');
		setLoading(true);
		toggleSidebar(true);

		try {
			const response = await fetch('/api/search', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ address, sectors })
			});

			if (!response.ok) throw new Error('Search failed');

			const data = await response.json();
			renderResults(data);
		} catch (error) {
			errorMessage.textContent = error instanceof Error ? error.message : 'Search failed';
			errorMessage.classList.remove('hidden');
		} finally {
			setLoading(false);
		}
	}

	// Event listeners
	searchBtn.addEventListener('click', handleSearch);
	addressInput.addEventListener('keypress', (e) => {
		if (e.key === 'Enter') handleSearch();
	});

	toggleSidebarBtn.addEventListener('click', () => toggleSidebar());
	openSidebarBtn.addEventListener('click', () => toggleSidebar(true));

	locationBtn.addEventListener('click', () => {
		if (!navigator.geolocation) {
			errorMessage.textContent = 'Geolocation is not supported by your browser.';
			errorMessage.classList.remove('hidden');
			return;
		}

		navigator.geolocation.getCurrentPosition(
			(position) => {
				userLat = position.coords.latitude;
				userLng = position.coords.longitude;
				addressInput.value = `${position.coords.latitude}, ${position.coords.longitude}`;
				handleSearch();
			},
			(error) => {
				errorMessage.textContent = `Location error: ${error.message}`;
				errorMessage.classList.remove('hidden');
			}
		);
	});
</script>
